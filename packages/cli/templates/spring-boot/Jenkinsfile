pipeline {
    agent any

    environment {
        PROJECT_NAME = '{{PROJECT_NAME}}'
        REGISTRY_URL = '{{REGISTRY_URL}}'
        IMAGE_TAG = "${env.GIT_COMMIT?.take(7) ?: 'latest'}"
        DOCKER_IMAGE = "${REGISTRY_URL}/${PROJECT_NAME}"
        // Gradle cache directory
        GRADLE_USER_HOME = "${WORKSPACE}/.gradle"
        // Enable Docker BuildKit for layer caching
        DOCKER_BUILDKIT = '1'
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '10'))
        disableConcurrentBuilds()
        timestamps()
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    // Record build start time
                    env.BUILD_START_TIME = System.currentTimeMillis().toString()
                }
            }
        }

        stage('Build') {
            parallel {
                stage('Compile') {
                    steps {
                        // Use Gradle build cache and dependency cache
                        sh '''
                            ./gradlew clean build -x test \
                                --no-daemon \
                                --build-cache \
                                --gradle-user-home ${GRADLE_USER_HOME} \
                                -Dorg.gradle.caching=true
                        '''
                    }
                }
                stage('Lint') {
                    steps {
                        sh './gradlew ktlintCheck --no-daemon --gradle-user-home ${GRADLE_USER_HOME} || true'
                    }
                }
            }
        }

        stage('Test') {
            parallel {
                stage('Unit Tests') {
                    steps {
                        sh './gradlew test --no-daemon'
                    }
                    post {
                        always {
                            junit allowEmptyResults: true, testResults: 'build/test-results/test/*.xml'
                            publishHTML(target: [
                                allowMissing: true,
                                alwaysLinkToLastBuild: true,
                                keepAll: true,
                                reportDir: 'build/reports/tests/test',
                                reportFiles: 'index.html',
                                reportName: 'Test Report'
                            ])
                        }
                    }
                }
{{#IF_POSTGRES}}
                stage('Integration Tests') {
                    steps {
                        sh './gradlew integrationTest --no-daemon || true'
                    }
                }
{{/IF_POSTGRES}}
            }
        }

        stage('Containerize') {
            steps {
                script {
                    // Use BuildKit with cache mounts for faster builds
                    sh '''
                        docker build \
                            --build-arg BUILDKIT_INLINE_CACHE=1 \
                            --cache-from ${DOCKER_IMAGE}:latest \
                            -t ${DOCKER_IMAGE}:${IMAGE_TAG} \
                            -t ${DOCKER_IMAGE}:latest \
                            .
                    '''
                }
            }
        }

        stage('Security Scan') {
            steps {
                script {
                    // Trivy vulnerability scan - fail on CRITICAL, warn on HIGH
                    sh """
                        trivy image --severity CRITICAL --exit-code 1 ${DOCKER_IMAGE}:${IMAGE_TAG} || exit 1
                        trivy image --severity HIGH --exit-code 0 ${DOCKER_IMAGE}:${IMAGE_TAG}
                    """
                }
            }
        }

        stage('Push') {
            steps {
                script {
                    sh "docker push ${DOCKER_IMAGE}:${IMAGE_TAG}"
                    sh "docker push ${DOCKER_IMAGE}:latest"
                }
            }
        }

{{#IF_KUBERNETES}}
        stage('Deploy Ephemeral') {
            when {
                changeRequest()
            }
            environment {
                NAMESPACE = "${PROJECT_NAME}-pr-${env.CHANGE_ID}"
            }
            steps {
                script {
                    sh """
                        kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                        kubectl label namespace ${NAMESPACE} ephemeral=true --overwrite

                        # Update image tag in kustomization
                        cd k8s/overlays/ephemeral
                        kustomize edit set image ${DOCKER_IMAGE}=${DOCKER_IMAGE}:${IMAGE_TAG}

                        # Apply manifests
                        kubectl apply -k . -n ${NAMESPACE}

                        # Wait for deployment
                        kubectl rollout status deployment/${PROJECT_NAME} -n ${NAMESPACE} --timeout=300s
                    """
                }
            }
            post {
                success {
                    script {
                        def serviceUrl = sh(
                            script: "kubectl get svc ${PROJECT_NAME} -n ${NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo 'pending'",
                            returnStdout: true
                        ).trim()
                        echo "Ephemeral environment deployed: ${serviceUrl}"
                    }
                }
            }
        }

        stage('Integration Tests (Ephemeral)') {
            when {
                changeRequest()
            }
            environment {
                NAMESPACE = "${PROJECT_NAME}-pr-${env.CHANGE_ID}"
            }
            steps {
                script {
                    // Wait for service to be ready
                    sh """
                        kubectl wait --for=condition=ready pod -l app=${PROJECT_NAME} -n ${NAMESPACE} --timeout=120s

                        # Run smoke tests against ephemeral environment
                        SERVICE_URL=\$(kubectl get svc ${PROJECT_NAME} -n ${NAMESPACE} -o jsonpath='{.spec.clusterIP}')
                        curl -f http://\${SERVICE_URL}:8080/health || exit 1
                        curl -f http://\${SERVICE_URL}:8080/ready || exit 1
                    """
                }
            }
        }

        stage('Deploy Staging') {
            when {
                branch 'main'
            }
            steps {
                script {
                    sh """
                        # Update image tag for staging
                        cd k8s/overlays/staging
                        kustomize edit set image ${DOCKER_IMAGE}=${DOCKER_IMAGE}:${IMAGE_TAG}

                        # Sync via Argo CD
                        argocd app sync ${PROJECT_NAME}-staging --timeout 300 || kubectl apply -k . -n ${PROJECT_NAME}-staging

                        # Wait for rollout
                        kubectl rollout status deployment/${PROJECT_NAME} -n ${PROJECT_NAME}-staging --timeout=300s
                    """
                }
            }
        }
{{/IF_KUBERNETES}}
    }

    post {
        always {
            script {
                // Calculate build duration
                def buildDuration = 0
                if (env.BUILD_START_TIME) {
                    buildDuration = (System.currentTimeMillis() - env.BUILD_START_TIME.toLong()) / 1000
                }
                env.BUILD_DURATION_SECONDS = buildDuration.toString()

                // Log build metrics
                echo "Build Metrics:"
                echo "  Project: ${PROJECT_NAME}"
                echo "  Duration: ${buildDuration}s"
                echo "  Image: ${DOCKER_IMAGE}:${IMAGE_TAG}"
                echo "  Result: ${currentBuild.result ?: 'SUCCESS'}"
            }
            cleanWs()
        }
{{#IF_KUBERNETES}}
        cleanup {
            script {
                // Teardown ephemeral environment after PR is merged
                if (env.CHANGE_ID && currentBuild.result != 'FAILURE') {
                    def namespace = "${PROJECT_NAME}-pr-${env.CHANGE_ID}"
                    sh "kubectl delete namespace ${namespace} --ignore-not-found=true || true"
                }
            }
        }
{{/IF_KUBERNETES}}
        success {
            script {
                echo "Pipeline completed successfully for ${PROJECT_NAME}"
                sendSlackNotification('success')
            }
        }
        failure {
            script {
                echo "Pipeline failed for ${PROJECT_NAME}"
                sendSlackNotification('failure')
            }
        }
    }
}

// Helper function for Slack notifications
def sendSlackNotification(String status) {
    // Try to get Slack webhook from credentials (optional)
    def slackWebhookUrl = ''
    try {
        withCredentials([string(credentialsId: 'slack-webhook-url', variable: 'SLACK_URL')]) {
            slackWebhookUrl = env.SLACK_URL
        }
    } catch (Exception e) {
        echo "Slack notifications not configured (credential 'slack-webhook-url' not found)"
        return
    }

    if (!slackWebhookUrl) {
        return
    }

    def color = status == 'success' ? 'good' : 'danger'
    def emoji = status == 'success' ? '✅' : '❌'
    def statusText = status == 'success' ? 'succeeded' : 'failed'
    def duration = env.BUILD_DURATION_SECONDS ?: '0'

    def payload = """{
        "text": "${emoji} *${env.PROJECT_NAME}* build ${statusText}",
        "attachments": [{
            "color": "${color}",
            "fields": [
                {"title": "Branch", "value": "${env.GIT_BRANCH ?: 'unknown'}", "short": true},
                {"title": "Commit", "value": "${env.IMAGE_TAG}", "short": true},
                {"title": "Duration", "value": "${duration}s", "short": true},
                {"title": "Build", "value": "#${env.BUILD_NUMBER}", "short": true}
            ],
            "footer": "<${env.BUILD_URL}|View Build>"
        }]
    }"""

    sh "curl -s -X POST -H 'Content-type: application/json' --data '${payload}' '${slackWebhookUrl}' || true"
}
